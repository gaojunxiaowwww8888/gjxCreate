<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>CesiumJS+ThreeJS</title>
  <link href="CesiumThree.css" rel="stylesheet" type="text/css">
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="ThreeContainer"></div>
  <!--<div id="cover">-->
    <!--<div id="loadingIndicator" class="loadingIndicator"></div>-->
  <!--</div>-->

  <script src="ThirdParty/Cesium/Cesium.js"></script>
  <script src="ThirdParty/newThree/three.js"></script>
  <script src="ThirdParty/newThree/OBJLoader.js"></script>
  <script src="ThirdParty/newThree/MTLLoader.js"></script>

  <script>

      var sperecloud;
//      var minWGS84 = [115.23,39.55];
//      var maxWGS84 = [116.23,41.55];

      var minWGS84 = [ 113.07334, 27.78055 ];
      var maxWGS84 = [ 113.06512, 27.78358 ];

      var cesiumContainer = document.getElementById("cesiumContainer");
      var ThreeContainer = document.getElementById("ThreeContainer");

      var _3Dobjects = []; //Could be any Three.js object mesh
      var three = {
          renderer: null,
          camera: null,
          scene: null
      };

      var cesium = {
          viewer: null
      };

      var modeMesh = {
          threeMesh: null, //Three.js 3DObject.mesh
          minWGS84: null, //location bounding box
          maxWGS84: null
      }

      function _3DObject(){
          this.threeMesh = null; //Three.js 3DObject.mesh
          this.minWGS84 = null; //location bounding box
          this.maxWGS84 = null;
      }

      function initCesium(){
          cesium.viewer = new Cesium.Viewer(cesiumContainer, {
              useDefaultRenderLoop: false,
              fullscreenButton: true,
              animation: true,
              baseLayerPicker: false,
              geocoder: true,
              homeButton: true,
              infoBox: true,
              sceneModePicker: true,
              selectionIndicator: true,
              timeline: false,
              navigationHelpButton: true,
              navigationInstructionsInitiallyVisible: true,
              imageryProvider : new Cesium.ArcGisMapServerImageryProvider({
                  url : 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer',
                  enablePickFeatures : false
              })

          });

          var entity = {

              name : 'Wyoming',
              show: true,
              polygon : {
                  hierarchy : Cesium.Cartesian3.fromDegreesArray([

                      minWGS84[0], minWGS84[1],
                      maxWGS84[0], minWGS84[1],
                      maxWGS84[0], maxWGS84[1],
                      minWGS84[0], maxWGS84[1],
                  ]),

                  material : Cesium.Color.RED.withAlpha( 0.4 ),
                  outline : true,
                  outlineColor : Cesium.Color.BLACK

              }
          };


          var wyoming = cesium.viewer.entities.add( entity );

          var center = Cesium.Cartesian3.fromDegrees(
              (minWGS84[0] + maxWGS84[0]) / 2,
              ((minWGS84[1] + maxWGS84[1]) / 2)-1,
              200000
          );

          cesium.viewer.camera.setView({
              position : center,
              heading : 0.0,
              pitch : -Cesium.Math.PI_OVER_TWO,
              roll : 0.0
          });

//    wyoming.position = Cesium.Cartesian3.fromDegrees(-107.724, 42.68);
//    cesium.viewer.trackedEntity = wyoming;
          cesium.viewer.zoomTo( wyoming );

//          var center = Cesium.Cartesian3.fromDegrees(
//              (minWGS84[0] + maxWGS84[0]) / 2,
//              ((minWGS84[1] + maxWGS84[1]) / 2)-1,
//              200000
//          );
//          cesium.viewer.camera.flyTo({
//              destination : center,
//              orientation : {
//                  heading : Cesium.Math.toRadians(0),
//                  pitch : Cesium.Math.toRadians(-60),
//                  roll : Cesium.Math.toRadians(0)
//              },
//              duration: 3
//          });
      }

      function initThree(){
          var fov = 45;
          var width = window.innerWidth;
          var height = window.innerHeight;
          var aspect = width / height;
          var near = 1;
          var far = 10*1000*1000; // needs to be far to support Cesium's world-scale rendering

          three.scene = new THREE.Scene();
          three.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          three.renderer = new THREE.WebGLRenderer({ alpha: true, maxLights: 1 });
          ThreeContainer.appendChild(three.renderer.domElement);

          var sg = new THREE.SphereGeometry( 20 );
          var sm = new THREE.Mesh( sg, new THREE.MeshNormalMaterial() );
          sm.visible = true;
          sm.position.set( 0, 100 , 0 );

          var ambiColor = "0x444444";
          var ambientLight = new THREE.AmbientLight( ambiColor, 1.5 );
          three.scene.add(ambientLight);

//          var spotLight = new THREE.SpotLight( 0xffffff, 3, 0, Math.PI/4 );
//          spotLight.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 700, 3000 ) );
//          spotLight.castShadow = true;
//          spotLight.shadow.mapSize.width = 2048;
//          spotLight.shadow.mapSize.height = 1024;
//
//          spotLight.shadow.camera.near = 1;
//          spotLight.shadow.camera.far = 10 * 1000 * 1000;
//          spotLight.shadow.camera.fov = 30;
//          spotLight.shadowDarkness = 0.5;
//          spotLight.shadow.bias = 0.0008;
//          spotLight.angle = Math.PI / 3;
//
//          spotLight.add( sm );
//          three.scene.add( spotLight );
//         sperecloud = spotLight;


      }

      function init3DObject(){
          //Cesium entity
          var entity = {
              name : 'Polygon',
              polygon : {
                  hierarchy : Cesium.Cartesian3.fromDegreesArray([
                      minWGS84[0], minWGS84[1],
                      maxWGS84[0], minWGS84[1],
                      maxWGS84[0], maxWGS84[1],
                      minWGS84[0], maxWGS84[1],
                  ]),
                  material : Cesium.Color.RED.withAlpha(0.2)
              }
          };
          var Polygon = cesium.viewer.entities.add(entity);

          // Lathe geometry
          var doubleSideMaterial = new THREE.MeshNormalMaterial({
              side: THREE.DoubleSide
          });
//          var segments = 10;
//          var points = [];
//          for ( var i = 0; i < segments; i ++ ) {
//              points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * segments + 5, ( i - 5 ) * 2 ) );
//          }
//          var geometry = new THREE.LatheGeometry( points );
//          var latheMesh = new THREE.Mesh( geometry, doubleSideMaterial ) ;
//          latheMesh.scale.set(1500,1500,1500); //scale object to be visible at planet scale
//          latheMesh.position.z += 15000.0; // translate "up" in Three.js space so the "bottom" of the mesh is the handle
//          latheMesh.rotation.x = Math.PI / 2; // rotate mesh for Cesium's Y-up system
//          var latheMeshYup = new THREE.Group();
//          latheMeshYup.add(latheMesh)
//          three.scene.add(latheMeshYup); // don’t forget to add it to the Three.js scene manually
//
//          //Assign Three.js object mesh to our object array
//          var _3DOB = new _3DObject();
//          _3DOB.threeMesh = latheMeshYup;
//          _3DOB.minWGS84 = minWGS84;
//          _3DOB.maxWGS84 = maxWGS84;
//          _3Dobjects.push(_3DOB);

          // dodecahedron
//          geometry = new THREE.DodecahedronGeometry();
//          var dodecahedronMesh = new THREE.Mesh(geometry, new THREE.MeshNormalMaterial()) ;
//          dodecahedronMesh.scale.set(5000,5000,5000); //scale object to be visible at planet scale
//          dodecahedronMesh.position.z += 15000.0; // translate "up" in Three.js space so the "bottom" of the mesh is the handle
//          dodecahedronMesh.rotation.x = Math.PI / 2; // rotate mesh for Cesium's Y-up system
//          var dodecahedronMeshYup = new THREE.Group();
////          dodecahedronMeshYup.add(dodecahedronMesh)
//          three.scene.add(dodecahedronMeshYup); // don’t forget to add it to the Three.js scene manually

          //Assign Three.js object mesh to our object array
          var _3DOB = new _3DObject();
//          _3DOB.threeMesh = dodecahedronMeshYup;
//          _3DOB.minWGS84 = minWGS84;
//          _3DOB.maxWGS84 = maxWGS84;
//          _3Dobjects.push(_3DOB);


          // texture
          var manager = new THREE.LoadingManager();
          manager.onProgress = function ( item, loaded, total ) {
          };
          var onProgress = function ( xhr ) {
              if ( xhr.lengthComputable ) {
                  var percentComplete = xhr.loaded / xhr.total * 100;
              }
          };
          var onError = function ( xhr ) {
          };

          // model
          var mtlLoader = new THREE.MTLLoader( manager );
          mtlLoader.setTexturePath( 'res/obj/' );
          mtlLoader.setPath( 'res/obj/' );

          mtlLoader.load( 'ty01.mtl', function( materials ) {

              materials.preload();
              var objLoader = new THREE.OBJLoader( manager );
              objLoader.setMaterials( materials );
              objLoader.setPath( 'res/obj/' );
              objLoader.load( 'ty01.obj', function ( object ) {

                  modeMesh.threeMesh = object;
                  modeMesh.minWGS84 = minWGS84;
                  modeMesh.maxWGS84 = maxWGS84;
//                modeMesh.threeMesh.scale.set( 100,100,100 ); //scale object to be visible at planet scale
//                  modeMesh.threeMesh.rotation.x = Math.PI / 2;
                  three.scene.add( modeMesh.threeMesh );

              }, onProgress, onError );
          });

      }

      function loop(){
          requestAnimationFrame(loop);
          renderCesium();
          renderThreeObj();
      }

      function renderCesium(){
          cesium.viewer.render();
      }

      function renderThreeObj(){
          // register Three.js scene with Cesium
          three.camera.fov = Cesium.Math.toDegrees(cesium.viewer.camera.frustum.fovy ); // ThreeJS FOV is vertical
          three.camera.updateProjectionMatrix();

          var cartToVec = function(cart){
              return new THREE.Vector3(cart.x, cart.y, cart.z);
          };

          // Configure Three.js meshes to stand against globe center position up direction
//          for(var id in _3Dobjects){
//              minWGS84 = _3Dobjects[id].minWGS84;
//              maxWGS84 = _3Dobjects[id].maxWGS84;
              // convert lat/long center position to Cartesian3

          if ( modeMesh.threeMesh != null ) {
              minWGS84 = modeMesh.minWGS84;
              maxWGS84 = modeMesh.maxWGS84;
//
              var center = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2);

              // get forward direction for orienting model
              var centerHigh = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2, 1 );

//              var center = Cesium.Cartesian3.fromDegrees(minWGS84[0], minWGS84[1]);
//
//              // get forward direction for orienting model
//              var centerHigh = Cesium.Cartesian3.fromDegrees(maxWGS84[0], maxWGS84[1] );

              // use direction from bottom left to top left as up-vector
              var bottomLeft  = cartToVec( Cesium.Cartesian3.fromDegrees(minWGS84[0], minWGS84[1]) );
              var topLeft = cartToVec( Cesium.Cartesian3.fromDegrees(minWGS84[0], maxWGS84[1]));
              var latDir  = new THREE.Vector3().subVectors(bottomLeft,topLeft ).normalize();

              if ( modeMesh.threeMesh != null ) {
//                  sperecloud.position.copy(center);
                  modeMesh.threeMesh.position.copy(center);
                  modeMesh.threeMesh.lookAt(centerHigh);
                  modeMesh.threeMesh.up.copy(latDir);
              }
          }
//              var center = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2);
//
//              // get forward direction for orienting model
//              var centerHigh = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2,1);
//
//              // use direction from bottom left to top left as up-vector
//              var bottomLeft  = cartToVec(Cesium.Cartesian3.fromDegrees(minWGS84[0], minWGS84[1]));
//              var topLeft = cartToVec(Cesium.Cartesian3.fromDegrees(minWGS84[0], maxWGS84[1]));
//              var latDir  = new THREE.Vector3().subVectors(bottomLeft,topLeft ).normalize();
//
//              if ( modeMesh != undefined ) {
//                  modeMesh.position.copy(center);
//                  modeMesh.lookAt(centerHigh);
//                  modeMesh.up.copy(latDir);
//              }

          // Clone Cesium Camera projection position so the
          // Three.js Object will appear to be at the same place as above the Cesium Globe
          three.camera.matrixAutoUpdate = false;
          var cvm = cesium.viewer.camera.viewMatrix;
          var civm = cesium.viewer.camera.inverseViewMatrix;
          three.camera.matrixWorld.set(
              civm[0], civm[4], civm[8 ], civm[12],
              civm[1], civm[5], civm[9 ], civm[13],
              civm[2], civm[6], civm[10], civm[14],
              civm[3], civm[7], civm[11], civm[15]
          );
          three.camera.matrixWorldInverse.set(
              cvm[0], cvm[4], cvm[8 ], cvm[12],
              cvm[1], cvm[5], cvm[9 ], cvm[13],
              cvm[2], cvm[6], cvm[10], cvm[14],
              cvm[3], cvm[7], cvm[11], cvm[15]
          );
          three.camera.lookAt(new THREE.Vector3(0,0,0));

          var width = ThreeContainer.clientWidth;
          var height = ThreeContainer.clientHeight;
          var aspect = width / height;
          three.camera.aspect = aspect;
          three.camera.updateProjectionMatrix();

          three.renderer.setSize(width, height);
          three.renderer.render(three.scene, three.camera);
      }

      initCesium(); // Initialize Cesium renderer
      initThree(); // Initialize Three.js renderer
      init3DObject(); // Initialize Three.js object mesh with Cesium Cartesian coordinate system
      loop(); // L

  </script>
</body>
</html>
