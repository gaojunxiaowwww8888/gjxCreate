<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version (or Chrome Frame if pre-IE11). -->
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>CesiumJS+ThreeJS</title>
  <link href="CesiumThree.css" rel="stylesheet" type="text/css" media="all">
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="ThreeContainer"></div>
  <!--<div id="cover">-->
    <!--<div id="loadingIndicator" class="loadingIndicator"></div>-->
  <!--</div>-->

  <script src="ThirdParty/Cesium/Cesium.js"></script>
  <script src="ThirdParty/newThree/three.js"></script>
  <script src="ThirdParty/newThree/OBJLoader.js"></script>
  <script src="ThirdParty/newThree/MTLLoader.js"></script>

  <script>

      var sperecloud;
      var minWGS84 = [115.23,39.55];
      var maxWGS84 = [116.23,41.55];

//      var minWGS84 = [ 113.07, 27.78 ];
//      var maxWGS84 = [ 113.06, 27.78 ];

      var cesiumContainer = document.getElementById("cesiumContainer");
      var ThreeContainer = document.getElementById("ThreeContainer");

      var three = {
          renderer: null,
          camera: null,
          scene: null
      };

      var cesium = {
          viewer: null
      };

      var modeMesh = {
          threeMesh: null, //Three.js 3DObject.mesh
          minWGS84: null, //location bounding box
          maxWGS84: null
      };

      function initCesium(){

          cesium.viewer = new Cesium.Viewer(cesiumContainer, {
              useDefaultRenderLoop: false,
              fullscreenButton: true,
              animation: true,
              baseLayerPicker: false,
              geocoder: true,
              homeButton: true,
              infoBox: true,
              sceneModePicker: true,
              selectionIndicator: true,
              timeline: false,
              navigationHelpButton: true,
              navigationInstructionsInitiallyVisible: true,
              contextOptions:{
                  webgl: {
                      alpha: false,
                      antialias: true,
                      preserveDrawingBuffer : true,
                      failIfMajorPerformanceCaveat: false,
                      depth:true,
                      stencil:false,
                  },
              },
              targetFrameRate:60,
              resolutionScale:0.1,
              orderIndependentTranslucency : true,
//              creditContainer : "hidecredit",
              imageryProvider : new Cesium.ArcGisMapServerImageryProvider({
                  url : 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer',
                  enablePickFeatures : false
              }),
              baseLayerPicker : false,
              geocoder : false,
              automaticallyTrackDataSourceClocks: false,
              dataSources: null,
              clock: null,
              terrainShadows: Cesium.ShadowMode.DISABLED
          });

          var entity = {
              name : 'Wyoming',
              show: true,
              polygon : {
                  hierarchy : Cesium.Cartesian3.fromDegreesArray([
                      minWGS84[0], minWGS84[1],
                      maxWGS84[0], minWGS84[1],
                      maxWGS84[0], maxWGS84[1],
                      minWGS84[0], maxWGS84[1],
                  ]),
                  material : Cesium.Color.RED.withAlpha( 0.4 ),
                  outline : true,
                  outlineColor : Cesium.Color.BLACK
              }
          };
          var wyoming = cesium.viewer.entities.add( entity );
          var center = Cesium.Cartesian3.fromDegrees(
              (minWGS84[0] + maxWGS84[0]) / 2,
              ((minWGS84[1] + maxWGS84[1]) / 2)-1,
              200000
          );

          cesium.viewer.camera.flyTo({
              destination : center,
              orientation : {
                  heading : Cesium.Math.toRadians(0),
                  pitch : Cesium.Math.toRadians(-60),
                  roll : Cesium.Math.toRadians(0)
              },
              duration: 3
          });

//          cesium.viewer.camera.setView({
//              position : center,
//              heading : 0.0,
//              pitch : -Cesium.Math.PI_OVER_TWO,
//              roll : 0.0
//          });

//    wyoming.position = Cesium.Cartesian3.fromDegrees(-107.724, 42.68);
//    cesium.viewer.trackedEntity = wyoming;
//          cesium.viewer.zoomTo( wyoming );
      }

      function initThree(){
          var fov = 45;
          var width = window.innerWidth;
          var height = window.innerHeight;
          var aspect = width / height;
          var near = 1;
          var far = 10*1000*1000; // needs to be far to support Cesium's world-scale rendering

          three.scene = new THREE.Scene();
          three.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
          three.renderer = new THREE.WebGLRenderer({ alpha: true, maxLights: 1 });
          ThreeContainer.appendChild(three.renderer.domElement);

          var sg = new THREE.SphereGeometry( 20 );
          var sm = new THREE.Mesh( sg, new THREE.MeshNormalMaterial() );
          sm.visible = true;
          sm.position.set( 0, 100 , 0 );

          var ambiColor = "0x444444";
          var ambientLight = new THREE.AmbientLight( ambiColor, 1.5 );
          three.scene.add(ambientLight);

      }

      function init3DObject(){
          //Cesium entity
          var entity = {
              name : 'Polygon',
              polygon : {
                  hierarchy : Cesium.Cartesian3.fromDegreesArray([
                      minWGS84[0], minWGS84[1],
                      maxWGS84[0], minWGS84[1],
                      maxWGS84[0], maxWGS84[1],
                      minWGS84[0], maxWGS84[1],
                  ]),
                  material : Cesium.Color.RED.withAlpha(0.2)
              }
          };
          var Polygon = cesium.viewer.entities.add(entity);

          // texture
          var manager = new THREE.LoadingManager();
          manager.onProgress = function ( item, loaded, total ) {
          };
          var onProgress = function ( xhr ) {
              if ( xhr.lengthComputable ) {
                  var percentComplete = xhr.loaded / xhr.total * 100;
              }
          };
          var onError = function ( xhr ) {
          };

          // model
          var mtlLoader = new THREE.MTLLoader( manager );
          mtlLoader.setTexturePath( 'obj02/' );
          mtlLoader.setPath( 'obj02/' );

          mtlLoader.load( 'ty.mtl', function( materials ) {

              materials.preload();
              var objLoader = new THREE.OBJLoader( manager );
              objLoader.setMaterials( materials );
              objLoader.setPath( 'obj02/' );
              objLoader.load( 'ty.obj', function ( object ) {

                  modeMesh.threeMesh = object;
                  modeMesh.minWGS84 = minWGS84;
                  modeMesh.maxWGS84 = maxWGS84;
                  modeMesh.threeMesh.scale.set( 1000,1000,1000 ); //scale object to be visible at planet scale
                  three.scene.add( modeMesh.threeMesh );

              }, onProgress, onError );
          });
      }

      function loop(){
          requestAnimationFrame(loop);
          renderCesium();
          renderThreeObj();
      }

      function renderCesium(){
          cesium.viewer.render();
      }

      function renderThreeObj(){
          // register Three.js scene with Cesium
          three.camera.fov = Cesium.Math.toDegrees( cesium.viewer.camera.frustum.fovy ); // ThreeJS FOV is vertical
          three.camera.updateProjectionMatrix();

          var cartToVec = function(cart){
              return new THREE.Vector3(cart.x, cart.y, cart.z);
          };

          if ( modeMesh.threeMesh != null ) {
              minWGS84 = modeMesh.minWGS84;
              maxWGS84 = modeMesh.maxWGS84;
//              var center = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2 );
//              // get forward direction for orienting model
//              var centerHigh = Cesium.Cartesian3.fromDegrees((minWGS84[0] + maxWGS84[0]) / 2, (minWGS84[1] + maxWGS84[1]) / 2, 1 );

              var center = Cesium.Cartesian3.fromDegrees(minWGS84[0], minWGS84[1]);
//              // get forward direction for orienting model
              var centerHigh = Cesium.Cartesian3.fromDegrees(maxWGS84[0], maxWGS84[1],1 );

              // use direction from bottom left to top left as up-vector
              var bottomLeft  = cartToVec( Cesium.Cartesian3.fromDegrees(minWGS84[0], minWGS84[1]) );
              var topLeft = cartToVec( Cesium.Cartesian3.fromDegrees(minWGS84[0], maxWGS84[1]),1);
              var latDir  = new THREE.Vector3().addVectors( topLeft, bottomLeft ).normalize();

              if ( modeMesh.threeMesh != null ) {
//                  sperecloud.position.copy(center);
                  modeMesh.threeMesh.position.copy( bottomLeft );
                  modeMesh.threeMesh.lookAt( topLeft );
                  modeMesh.threeMesh.up.copy( latDir );
//                  modeMesh.threeMesh.rotation.x = -145;
              }
          }

          // Clone Cesium Camera projection position so the
          // Three.js Object will appear to be at the same place as above the Cesium Globe
          three.camera.matrixAutoUpdate = false;
          var cvm = cesium.viewer.camera.viewMatrix;
          var civm = cesium.viewer.camera.inverseViewMatrix;

          three.camera.matrixWorld.set(
              civm[0], civm[4], civm[8 ], civm[12],
              civm[1], civm[5], civm[9 ], civm[13],
              civm[2], civm[6], civm[10], civm[14],
              civm[3], civm[7], civm[11], civm[15]
          );
          three.camera.matrixWorldInverse.set(
              cvm[0], cvm[4], cvm[8 ], cvm[12],
              cvm[1], cvm[5], cvm[9 ], cvm[13],
              cvm[2], cvm[6], cvm[10], cvm[14],
              cvm[3], cvm[7], cvm[11], cvm[15]
          );
          three.camera.lookAt(new THREE.Vector3(0,0,0));

          var width = ThreeContainer.clientWidth;
          var height = ThreeContainer.clientHeight;
          var aspect = width / height;
          three.camera.aspect = aspect;
          three.camera.updateProjectionMatrix();

          three.renderer.setSize(width, height);
          three.renderer.render(three.scene, three.camera);
      }

      initCesium(); // Initialize Cesium renderer
      initThree(); // Initialize Three.js renderer
      init3DObject(); // Initialize Three.js object mesh with Cesium Cartesian coordinate system
      loop(); // L

  </script>
</body>
</html>
